#This function returns matrix mapping symbols to entrez gene ids 
map_entrez <- function(o){
  colnames(o)[1] <- "gene_symbol"
  colnames(o)
  n <- sqldf("select * from o left join annotation_entrez on o.gene_symbol = annotation_entrez.external_gene_name")
  n <- n[,c("gene_symbol", "entrezgene", "logFC")]
  n <- na.omit(n)
  n
}

#This function takes the output of findExchReact, finds the columns of interest to me,
#and returns a dataframe
react2df <- function(o){
  o <- as.data.frame(cbind(o@react_id, o@met_id, o@uptake, o@lowbnd, o@uppbnd))
  colnames(o) <- c("react_id", "met_id", "uptake", "lower_bound", "upper_bound")
  o
  final_output <- sqldf("select * from o left join annotation_metabolites on o.met_id =
                        annotation_metabolites.metabolite_id")
  final_output <- final_output[,c("react_id", "met_id", "metabolite_name","uptake","lower_bound",
                                  "upper_bound")]
  final_output
}

#This function binds annotation to the rates generated by getFluxDiff
annotate_reactions <- function(o){
  final_output <- cbind(o, annotation_reactions[,c("reaction_id", "reaction_name", "GPR")])
  colnames(final_output) <- c("Flux", "react_id", "react_name", "GPR")
  final_output <- final_output[,c("react_id", "Flux", "react_name", "GPR")]
  final_output
}

#This function returns all metabolites and their coefficients for the given reaction
get_metabolites <- function(model, reaction){
  s_mat <- S(model)
  colnames(s_mat) <- model@react_id
  rownames(s_mat) <- model@met_id
  s_mat <- s_mat[,grepl(reaction, colnames(s_mat), fixed=T)]
  s_mat <- s_mat[s_mat !=0]
  s_mat
}

#This function tests whether the model can make the specified biomass metabolites from the initial constraints
#It returns a vector of objective coefficient for each metabolite
biomass_test <- function(model, metabolites, solver="cplexAPI"){
  output <- vector(mode="numeric", length=length(metabolites))
  names(output) <- metabolites
  for(i in 1:length(metabolites)){
    print(paste0("Testing metabolite:", metabolites[i]))
    mdm <- paste0("DM_",metabolites[i])
    revised_model <- addReact(model, id=mdm, met=metabolites[i], Scoef=-1, )
    revised_model <- changeObjFunc(revised_model, react=mdm, obj_coef=1)
    predicted_fluxes <- optimizeProb(revised_model, algorithm="fba", solver=solver)
    output[i] <- mod_obj(predicted_fluxes)
  }
  output
}

#This function iterates through the provided reactions, blocks their availability, and returns
#the value of the objective function.  Reaction name must match those in rect_id(model)
essential_test <- function(model, reactions, solver="cplexAPI"){
  output <- vector(mode="numeric", length=length(reactions))
  names(output) <- reactions
  for(i in 1:length(reactions)){
    print(paste0("Iterating through reaction:", reactions[i]))
    revised_model <- changeBounds(model, react=reactions[i], lb=0, ub=0)
    predicted_fluxes <- optimizeProb(revised_model, algorithm="fba", solver=solver)
    output[i] <- mod_obj(predicted_fluxes)
  }
  output
}

#This function iterates through the elements
essential_elements_test <- function(model, reactions, solver="cplexAPI"){
  output <- vector(mode="numeric", length=length(reactions))
  names(output) <- reactions
  for(i in 1:length(reactions)){
    print(paste0("Iterating through reaction:", reactions[i]))
    revised_model <- changeBounds(model, react=reactions[i], lb=0, ub=0)
    predicted_fluxes <- optimizeProb(revised_model, algorithm="fba", solver=solver)
    output[i] <- mod_obj(predicted_fluxes)
  }
  output
}

#This function takes the results from fluxVar and rewrites them into a convenient matrix
fluxvar_rewrite <- function(o){
  results_vector <- o@lp_obj
  reactions_tested <- o@react@react_id
  output_mat <- matrix(results_vector, byrow=F, ncol=2, nrow=length(reactions_tested))
  colnames(output_mat) <- c("Min", "Max")
  rownames(output_mat) <- reactions_tested
  output_mat
}

#This function binds annotation to a matrix or dataframe.  It assumes rownames contain reaction ids
bind_annotation <- function(o){
  o <- as.data.frame(o)
  o <- as.data.frame(cbind(rownames(o),o))
  colnames(o)[1] <- "react_ids"
  m <- sqldf("select * from o left join annotation_reactions on o.react_ids = annotation_reactions.abbreviation")
  m
}

#This function gets all the reaction for the given metabolite in all compartments
get_reactions <- function(metabolite, model){
  s_mat <- S(model)
  colnames(s_mat) <- react_id(model)
  rownames(s_mat) <- met_id(model)
  
  search_space <- glob2rx(paste0(metabolite,"[*]"))
  mets <- rownames(s_mat)[grep(search_space, rownames(s_mat))]
  message("Found these metabolites corresponding to the input:", mets)
  s_mat <- s_mat[rownames(s_mat) %in% mets,]
  s_mat <- s_mat[,colSums(abs(s_mat)) > 0 ]
  s_mat
  s_mat
}

#This function iterates through the provided reaction fluxes and returns the values of the predictions
gradient_test <- function(model, concentrations, reaction, solver="cplexAPI"){
  output <- matrix(0, ncol=length(concentrations), nrow=length(react_id(model)))
  for(i in 1:length(concentrations)){
    print(paste0("Iterating through concentration:", concentrations[i]))
    revised_model <- changeBounds(model, react=reaction, lb=0, ub=concentrations[i])
    predicted_fluxes <- optimizeProb(revised_model, algorithm="fba", solver=solver)
    output[,i] <- getFluxDist(predicted_fluxes)
  }
  rownames(output) <- react_id(model)
  colnames(output) <- concentrations
  output
}

#This function takes the two dataframes from Test 4 and finds intervals of mutually exclusive regions
range_find <- function(o,j){
  os <- o + 1000
  js <- j + 1000
  output <- vector(mode="logical", length=nrow(o))
  for(i in 1:nrow(o)){
    output[i] <- os[i,"Min"] < js[i,"Max"] && os[i,"Max"] < js[i,"Min"] | 
      os[i,"Min"] > js[i,"Max"] && os[i,"Max"] > js[i,"Min"] 
  }
  output
}

#This function takes the 3 depots ranges, computes the set of mutually exclusive fluxes, and prepares a dataframe
#ready for plotting
range_compare <- function(l,m,n){
  set1 <- range_find(l,m)
  set2 <- range_find(l,n)
  set3 <- range_find(m,n)
  
  rxns <- rownames(l)
  complete_set <- unique(c(rxns[set1],rxns[set2],rxns[set3]))
  output <- cbind(l,m,n)
  colnames(output) <- c("SC_low", "SC_high", "MES_low", "MES_high", "OM_low", "OM_high")
  output <- output[complete_set,]
  output
}

#This function does FVA n times and iterating the bounds of the specific reaction.  It returns a named list of results
#whose length is equal to the number of iterations.
FVA_test <- function(model, reactions4fva, reactions2vary, upbnds, lobnds, cores){
  iterations <- length(upbnds)
  output_list <- vector("list", length=length(upbnds))
  
  for(i in 1:iterations){
    model_new <- changeBounds(model, react=reactions2vary, lb=lobnds[i], ub=upbnds[i])
    predicted_fluxes <- multiDel(model_new, del1=reactions4fva, nProc=cores, todo="fluxVar")
    predicted_fluxes_df <- lapply(predicted_fluxes, fluxvar_rewrite)
    predicted_fluxes_df <- do.call("rbind", predicted_fluxes_df)
    output_list[i] <- list(predicted_fluxes_df)
    names(output_list)[i] <- paste0(paste0(reactions2vary, collapse="-"),"_", lobnds[i], "_", upbnds[i])
  }
  output_list
}

#This function takes the output of FVA test and calculates the mean per reaction.
FVA_mean <- function(o, mean_only=T){
  mean_vector <- rowMeans(o)
  if(mean_only==T){
    k <- mean_vector  
  }
  else { 
    k <- cbind(o, mean_vector)
    colnames(k)[3] <- "Mean"
  k
  }
  k
}

#This funtion sorts the output of range find by the magnitude of the difference in means of the two ranges
range_sort <- function(o){
  mean_1 <- rowMeans(o[,c("Min_low", "Max_low")])
  mean_2 <- rowMeans(o[,c("Max_high", "Max_high")])
  diff_mean <- mean_1 - mean_2
  j <- cbind(o,diff_mean)
  colnames(j)[5] <- "Mean_diff"
  j <- j[order(abs(j[,"Mean_diff"]), decreasing=T),]
  j
}

#This function compares that means between the possible comparisons and sorts them based on the average mean difference
#Caution: due to laziness, order matters. Thus, i,j,k should correspond to sc,mes,om
range_compare_soft <- function(i,j,k){
  sc_mean <- apply(i,1,mean)
  mes_mean <- apply(j,1,mean)
  om_mean <- apply(k,1,mean)
  
  sc_om <- sc_mean - om_mean
  sc_mes <- sc_mean - mes_mean
  mes_om <- mes_mean - om_mean
  
  mean_diff <- abs(sc_om) + abs(sc_mes) + abs(mes_om)
  
  output_mat <- cbind(i,j,k,mean_diff)
  colnames(output_mat) <- c("sc_min", "sc_max", "mes_min", "mes_max","om_min","om_max","mean_diff")
  output_mat <- output_mat[order(abs(output_mat[,"mean_diff"]), decreasing=T),]
}

#A variation of essential_test that iterates through each DMEM metabolite to find the rate limiting substrate
#Primarily for the Turner 2014 constraints
biomass_limit <- function(model, reactions, solver="cplexAPI"){
  output <- vector(mode="numeric", length=length(reactions))
  names(output) <- reactions
  for(i in 1:length(reactions)){
    print(paste0("Iterating through reaction:", reactions[i]))
    revised_model <- changeBounds(model, react=reactions[i], lb=0, ub=1000)
    predicted_fluxes <- optimizeProb(revised_model, algorithm="fba", solver=solver)
    output[i] <- mod_obj(predicted_fluxes)
  }
  output
}

#This function is a modified version of fluxVar that allows us to constraint the sum of the fluxes beforehand.
fluxVar_v2 <- function (model, react = c(1:react_num(model)), exex = FALSE, 
                        ...) 
{
  if (!is(model, "modelorg")) {
    stop("needs an object of class modelorg!")
  }
  if (isTRUE(exex)) {
    exchReact <- findExchReact(model)
    ex <- react_pos(exchReact)
    intReact <- 1:react_num(model)
    intReact <- intReact[-ex]
    if (length(intReact) < 1) {
      stop("model contains no internal reactions!")
    }
  }
  else {
    intReact <- react
  }
  creact <- checkReactId(model, intReact)
  if (!is(creact, "reactId")) {
    stop("check argument react")
  }
  sol <- optimizer(model, react = as.list(c(react_pos(creact), 
                                            react_pos(creact))), obj_coef = rep(1, (2 * length(creact))), 
                   lpdir = c(rep("min", length(creact)), rep("max", length(creact))), 
                   algorithm = "easyConstraintfv", ...)
  optsol <- new("optsol_fluxVar")
  opt <- makeOptsolMO(model, sol)
  as(optsol, "optsol_optimizeProb") <- opt
  react(optsol) <- creact
  return(optsol)
}

#A modification of multiDel that allows parallelization of the new algorithm 'easyConstraintfv'
multiDel_v2 <- function (model, nProc = 2, todo = "oneGeneDel", del1 = NA, 
          del2 = NA, ...) 
{
  if (!is(model, "modelorg")) {
    stop("needs an object of class modelorg!")
  }
  if (nProc < 2) {
    stop("argument nProc must be equal or greater than 2!")
  }
  spDel <- function(del) {
    if (is(del, "matrix")) {
      nd <- ncol(del)
      splitmat <- TRUE
    }
    else {
      nd <- length(del)
      splitmat <- FALSE
    }
    if (numCo > nd) {
      numCo <- nd
    }
    if (isTRUE(splitmat)) {
      gs <- floor(seq(1, nd, length.out = numCo + 1))
      dL <- vector(mode = "list", length = numCo)
      for (i in seq(along = gs[1:numCo])) {
        en <- ifelse(i == numCo, gs[i + 1], gs[i + 1] - 
                       1)
        dL[[i]] <- del[, gs[i]:en, drop = FALSE]
      }
    }
    else {
      gs <- floor(seq(0, nd, length.out = numCo + 1))
      spf <- cut(1:nd, gs)
      dL <- split(del, spf)
    }
    return(dL)
  }
  if (!requireNamespace("parallel", quietly = TRUE)) {
    stop("package parallel not found.")
  }
  ncore <- parallel::detectCores()
  numCo <- ifelse(nProc > ncore, as.integer(ncore), as.integer(nProc))
  if (any(is.na(del1))) {
    dL1 <- spDel(allGenes(model))
  }
  else {
    dL1 <- spDel(del1)
  }
  if (any(is.na(del2))) {
    dL2 <- as.list(rep(NA, length(dL1)))
  }
  else {
    if (length(del1) != length(del2)) {
      stop(paste("if argument del2 is not NA,", "del1 and del2 must have same length!"))
    }
    dL2 <- spDel(del2)
    cdL <- vector("list", length(dL1))
    for (i in seq(along = cdL)) {
      cdL[[i]] <- c(dL1[i], dL2[i])
    }
  }
  sol <- switch(todo, oneGeneDel = {
    parallel::mclapply(dL1, function(x) oneGeneDel(model, 
                                                   geneList = x, verboseMode = 0, ...), mc.cores = nProc)
  }, doubleGeneDel = {
    parallel::mclapply(cdL, function(x) doubleGeneDel(model, 
                                                      geneList1 = x[[1]], geneList2 = x[[2]], verboseMode = 0, 
                                                      ...), mc.cores = nProc)
  }, oneFluxDel = {
    parallel::mclapply(dL1, function(x) oneFluxDel(model, 
                                                   react = x, verboseMode = 0, ...), mc.cores = nProc)
  }, doubleFluxDel = {
    parallel::mclapply(cdL, function(x) doubleFluxDel(model, 
                                                      react1 = x[[1]], react2 = x[[2]], verboseMode = 0, 
                                                      ...), mc.cores = nProc)
  }, fluxVar = {
    parallel::mclapply(dL1, function(x) fluxVar(model, react = x, 
                                                verboseMode = 0, ...), mc.cores = nProc)
  }, fluxVar_v2 = {
    parallel::mclapply(dL1, function(x) fluxVar_v2(model, react = x, 
                                                verboseMode = 0, ...), mc.cores = nProc)
  }, geneDeletion = {
    parallel::mclapply(dL1, function(x) geneDeletion(model, 
                                                     genes = x, verboseMode = 0, ...), mc.cores = nProc)
  }, {
    stop("argument todo is not valid!")
  })
  return(sol)
}

#A modified form of ACHR that incoporates a total flux constraint:
ACHR_v2 <- function (model, W = 2000, nPoints = 5000, stepsPerPoint = 10, 
          solver = SYBIL_SETTINGS("SOLVER"), method = SYBIL_SETTINGS("METHOD"), easyConstraint=NULL) 
{
  #lpmod <- sybil::sysBiolAlg(model, solver = solver, method = method)
  lpmod <- new("sysBiolAlg_fbaEasyConstraint", model=model,solver=solver, method=method, easyConstraint=easyConstraint)
  print(lpmod)
  nRxns = react_num(model)
  if (W < 2 * nRxns) {
    stop("Warmup points should be more than double the number of rxns")
  }
  warmupPts = matrix(0,nrow=nRxns, ncol = W)
  for (i in (1:floor(W/2))) {
    if (i <= nRxns) {
      ocf = rep(0, nRxns)
      ocf[i] = 1
    }
    else {
      ocf = runif(nRxns) - 0.5
    }
    changeObjCoefs(problem(lpmod), c(1:nRxns), ocf)
    for (minMax in c("min", "max")) {
      setObjDir(problem(lpmod), minMax)
      sol = optimizeProb(lpmod)
      x = sol$fluxes
      status = sol$stat
      if ((status == 5 && solver == "glpkAPI") || (status == 
                                                     1 && solver == "cplexAPI")) {
        validFlag = TRUE
      }
      else {
        print("invalid solution")
        validFlag = FALSE
        print(status)
      }
      x[x > uppbnd(model)] = uppbnd(model)[x > uppbnd(model)]
      x[x < lowbnd(model)] = lowbnd(model)[x < lowbnd(model)]
      if (minMax == "min") {
        warmupPts[, 2 * i - 1] = x
      }
      else {
        warmupPts[, 2 * i] = x
      }
    }
    if (validFlag) {
      i = i + 1
    }
  }
  centerPoint = apply(warmupPts, 1, mean)
  warmupPts = warmupPts * 0.33 + 0.67 * centerPoint
  N = MASS::Null(t(S(model)))
  maxMinTol = 1e-09
  uTol = 1e-09
  dTol = 1e-14
  totalStepCount = 0
  prevPoint = centerPoint
  nProj = 0
  totalCount = nPoints * stepsPerPoint
  print("File #\tPoint #\tStep #\tTime\t#Time left\n")
  Points = matrix(rep(0, nRxns * nPoints), ncol = nPoints)
  pointCount = 1
  while (pointCount <= nPoints) {
    randVector = runif(stepsPerPoint)
    stepCount = 1
    while (stepCount <= stepsPerPoint) {
      a = ceiling(W * runif(1))
      xa = warmupPts[, a]
      u = (xa - centerPoint)
      u = u/norm(as.matrix(u), "F")
      distUb = (uppbnd(model) - prevPoint)
      distLb = (prevPoint - lowbnd(model))
      validDir = ((distUb > dTol) & (distLb > dTol))
      posDirn = which(u[validDir] > uTol)
      negDirn = which(u[validDir] < -uTol)
      maxStepTemp = distUb[validDir]/u[validDir]
      minStepTemp = -distLb[validDir]/u[validDir]
      maxStepVec = c(maxStepTemp[posDirn], minStepTemp[negDirn])
      minStepVec = c(minStepTemp[posDirn], maxStepTemp[negDirn])
      maxStep = min(maxStepVec)
      minStep = max(minStepVec)
#       print(sprintf("step %d: %f  %f", stepCount, minStep, 
#                     maxStep))
      if ((abs(minStep) < maxMinTol && abs(maxStep) < 
             maxMinTol) || (minStep > maxStep)) {
        print(sprintf("Warning %f %f\n", minStep, maxStep))
        next
      }
      stepDist = randVector[stepCount] * (maxStep - minStep) + 
        minStep
      curPoint = matrix(prevPoint + stepDist * u, ncol = 1)
      if ((totalStepCount%%stepsPerPoint) == 0) {
        #print(sprintf("totalStepCount %d", totalStepCount))
        if (max(abs(S(model) %*% curPoint)) > 1e-09) {
          curPoint = N %*% (t(N) %*% curPoint)
          nProj = nProj + 1
        }
      }
      curPoint[curPoint > uppbnd(model)] = uppbnd(model)[curPoint > 
                                                           uppbnd(model)]
      curPoint[curPoint < lowbnd(model)] = lowbnd(model)[curPoint < 
                                                           lowbnd(model)]
      prevPoint = curPoint
      stepCount = stepCount + 1
      totalStepCount = totalStepCount + 1
      centerPoint = ((W + totalStepCount) * centerPoint + 
                       curPoint)/(W + totalStepCount + 1)
    }
    Points[, pointCount] = curPoint
    pointCount = pointCount + 1
  }
  return(list(wpts = warmupPts, totalStepCount = totalStepCount, 
              curPoint = curPoint, Points = Points, W = W, nPoints = nPoints, 
              centerPoint = centerPoint, nProj = nProj))
}

#This function iterates through depot_reactions and saves each reaction as its own plot
plot_reactions <- function(o, dir_name=NULL){
  reactions <- o[,"react_ids"]
  names <- o[,"name"]
  input_df <- data.frame(matrix(0, nrow=3,ncol=3))
  colnames(input_df) <- c("Tissue", "Min", "Max")
  
  output_dir <- dir_name
  dir.create(paste0("./output_files/",dir_name))
  
  for(i in 1:length(reactions)){
    input_df[,"Tissue"] <- c("SC", "MES", "OM")
    input_df[,"Min"] <- as.numeric(o[i,c("sc_min", "mes_min", "om_min")])
    input_df[,"Max"] <- as.numeric(o[i,c("sc_max", "mes_max", "om_max")])
    
    ggplot(input_df, aes(x=Tissue))+ 
      theme_classic(20) +
      geom_linerange(aes(ymin=Min, ymax=Max), size=2) +
      geom_point(aes(y=Min), size=2) +
      geom_point(aes(y=Max), size=2) +
      ggtitle(paste(strwrap(names[i], width=40), collapse="\n")) +
      labs(y="Flux [mmol/gDw/hr]")+
      theme(axis.text.x=element_text(angle=90, hjust=1), axis.ticks.x=element_blank())
    ggsave(filename=paste0("./output_files/",dir_name,"/",reactions[i],".png"), width=7, height=7)   
  }
}

#This functions samples the input measurements and returns a matrix of the sampled values.
sample_seahorse <- function(o){
  output_mat <- o
  for(i in 1:length(unique(o$Tissue))){
    output_mat[i,"OCR_basal"] <- rnorm(1,mean=o[i,"OCR_basal"],sd=o[i,"OCR_basal_sd"])
    output_mat[i,"OCR_oligo"] <- rnorm(1,mean=o[i,"OCR_oligo"],sd=o[i,"OCR_oligo_sd"])
    output_mat[i,"OCR_fccp"] <- rnorm(1,mean=o[i,"OCR_fccp"],sd=o[i,"OCR_fccp_sd"])
    output_mat[i,"OCR_rotenone"] <- rnorm(1,mean=o[i,"OCR_rotenone"],sd=o[i,"OCR_rotenone_sd"])
    
    output_mat[i,"PPR_basal"] <- rnorm(1,mean=o[i,"PPR_basal"],sd=o[i,"PPR_basal_sd"])
    output_mat[i,"PPR_oligo"] <- rnorm(1,mean=o[i,"PPR_oligo"],sd=o[i,"PPR_oligo_sd"])
    output_mat[i,"PPR_fccp"] <- rnorm(1,mean=o[i,"PPR_fccp"],sd=o[i,"PPR_oligo_sd"])
    output_mat[i,"PPR_rotenone"] <- rnorm(1,mean=o[i,"PPR_rotenone"],sd=o[i,"PPR_rotenone_sd"])
    
    output_mat[i,"ATP_flux"] <- 4.6*(output_mat[i,"OCR_basal"] - output_mat[i,"OCR_oligo"])
    output_mat[i,"ATP_leak"] <- 4.6*(output_mat[i,"OCR_oligo"] - output_mat[i,"OCR_rotenone"])
  }
  return(output_mat)
}

#This functions samples the input measurements and returns a matrix of the sampled values.
#modified for the tseng dataset
sample_seahorse_tseng <- function(o){
  output_mat <- o
  for(i in 1:length(unique(o$Tissue))){
    output_mat[i,"OCR_basal"] <- rnorm(1,mean=o[i,"OCR_basal"],sd=o[i,"OCR_basal_sd"])
    output_mat[i,"OCR_oligo"] <- rnorm(1,mean=o[i,"OCR_oligo"],sd=o[i,"OCR_oligo_sd"])
    output_mat[i,"OCR_fccp"] <- rnorm(1,mean=o[i,"OCR_fccp"],sd=o[i,"OCR_fccp_sd"])
    output_mat[i,"OCR_rotenone"] <- rnorm(1,mean=o[i,"OCR_rotenone"],sd=o[i,"OCR_rotenone_sd"])
        
    output_mat[i,"PPR_basal"] <- rnorm(1,mean=o[i,"PPR_basal"],sd=o[i,"PPR_basal_sd"])
    output_mat[i,"PPR_oligo"] <- rnorm(1,mean=o[i,"PPR_oligo"],sd=o[i,"PPR_oligo_sd"])
    output_mat[i,"PPR_fccp"] <- rnorm(1,mean=o[i,"PPR_fccp"],sd=o[i,"PPR_oligo_sd"])
    output_mat[i,"PPR_rotenone"] <- rnorm(1,mean=o[i,"PPR_rotenone"],sd=o[i,"PPR_rotenone_sd"])
    
    output_mat[i,"glucose_uptake"] <- rnorm(1,mean=o[i,"glucose_uptake"], sd=o[i,"glucose_uptake_sd"])
    output_mat[i,"Palmitate_uptake"] <- rnorm(1,mean=o[i,"Palmitate_uptake"], sd=o[i,"Palmitate_uptake_sd"])
    
    output_mat[i,"ATP_flux"] <- 4.6*(output_mat[i,"OCR_basal"] - output_mat[i,"OCR_oligo"])
    output_mat[i,"ATP_leak"] <- 4.6*(output_mat[i,"OCR_oligo"] - output_mat[i,"OCR_rotenone"])
  }
  return(output_mat)
}

sample_nova_tseng <- function(o){
  output_mat <- o
  for(i in 1:length(unique(o$Tissue))){
    output_mat[i,"Gln_mean"] <- rnorm(1,mean=o[i,"Gln_mean"],sd=o[i,"Gln_se"])
    output_mat[i,"Glu_mean"] <- rnorm(1,mean=o[i,"Glu_mean"],sd=o[i,"Glu_se"])
    output_mat[i,"Gluc_mean"] <- rnorm(1,mean=o[i,"Gluc_mean"],sd=o[i,"Gluc_se"])
    output_mat[i,"Lac_mean"] <- rnorm(1,mean=o[i,"Lac_mean"],sd=o[i,"Lac_se"])
    
    output_mat[i,"NH4._mean"] <- rnorm(1,mean=o[i,"NH4._mean"],sd=o[i,"NH4._se"])
    output_mat[i,"Na._mean"] <- rnorm(1,mean=o[i,"Na._mean"],sd=o[i,"Na._se"])
    output_mat[i,"K._mean"] <- rnorm(1,mean=o[i,"K._mean"],sd=o[i,"K._se"])
    }
  return(output_mat)
}


#A modification on the BiGGR function to allow drawing from the sybil model object
#Not the most intuitive picture is drawn, but it's automated
model2hyperdraw <- function (sbml_model, rates = NULL, relevant.species = met_id(sbml_model), 
                             relevant.reactions = react_id(sbml_model), layoutType = "dot", lwd.max = 3, lwd.min = 0.5, 
                             plt.margins = c(150, 150, 150, 150), minor_metabolites=NULL) 
{
  mini_model <- S(sbml_model)
  colnames(mini_model) <- react_id(sbml_model)
  rownames(mini_model) <- met_id(sbml_model)
  mini_model <- mini_model[,colnames(mini_model) %in% relevant.reactions]
  mini_model <- mini_model[rownames(mini_model) %in% relevant.species,]
  mini_model <- mini_model[rowSums(abs(mini_model)) != 0,]
  
  print(mini_model)
  
  hyper_edges <- vector("list", length=ncol(mini_model))
  names(hyper_edges) <- colnames(mini_model)
  
  if (hasArg(rates)) {
    names(hyper_edges) <- paste(names(hyper_edges), ":", round(rates, 
                                                               2)[names(hyper_edges)], sep = "")
    names(rates) <- paste(names(rates), ":", round(rates, 
                                                   2), sep = "")
  }
  else {
    rates <- rep(1, ncol(mini_model))
    names(rates) <- colnames(mini_model)
  }
  
  for(i in 1:ncol(mini_model)){
      reaction_label <- names(hyper_edges)[i]
      reactants <- rownames(mini_model)[mini_model[,i] < 0]
      products <- rownames(mini_model)[mini_model[,i] > 0]
      reactants[reactants %in% minor_metabolites] <- paste0(reactants[reactants %in% minor_metabolites],"_",i)
      products[products %in% minor_metabolites] <- paste0(products[products %in% minor_metabolites],"_",i)
      hyper_edges[i] <- DirectedHyperedge(reactants, products, label=reaction_label)
    }
  
  node.names <- unique(unlist(c(lapply(hyper_edges, function(x) x@head), 
                                lapply(hyper_edges, function(x) x@tail))))
  hg <- Hypergraph(node.names, hyper_edges)
  testbph <- graphBPH(hg)
  my.graph <- graphLayout(testbph, layoutType = layoutType)
  nodeDataDefaults(my.graph, "shape") <- "circle"
  nodeDataDefaults(my.graph, "margin") <- "unit(3, \"mm\")"
  nodeData(my.graph,names(hyper_edges),"color") <- "blue"
  
  if (hasArg(minor_metabolites)) {
    mm_search <- paste0("^",minor_metabolites, collapse="|")
    mm_search <- gsub("\\]", "\\\\]", mm_search)
    mm_search <- gsub("\\[", "\\\\[", mm_search)
    graph_nodes <- my.graph@nodes
    minor_metabolites_v2 <- graph_nodes[grep(mm_search, graph_nodes)]
    nodeData(my.graph, minor_metabolites_v2,"shape") <- "plain"
    nodeData(my.graph, minor_metabolites_v2, "color") <- "gray90"
  }
  
  edgeDataDefaults(my.graph, "lwd") <- 1
  graphDataDefaults(my.graph, "arrowLoc") <- "end"
  lwds <- abs(rates[my.graph@edgeNodes])/max(abs(rates[my.graph@edgeNodes])) * 
  lwd.max
  lwds[which(lwds < lwd.min)] <- lwd.min
  for (rxn.id in names(rates)) {
    if (unname(rates[rxn.id]) == 0) {
      lapply(my.graph@edgeNodeIO$outgoing[[rxn.id]], function(x) edgeData(my.graph, 
                                                                          rxn.id, x, "color") <- "grey")
      lapply(my.graph@edgeNodeIO$incoming[[rxn.id]], function(x) edgeData(my.graph, 
                                                                          x, rxn.id, "color") <- "grey")
    }
    if (unname(rates[rxn.id]) < 0) {
      lapply(my.graph@edgeNodeIO$outgoing[[rxn.id]], function(x) edgeData(my.graph, 
                                                                          rxn.id, x, "color") <- "green")
      lapply(my.graph@edgeNodeIO$incoming[[rxn.id]], function(x) edgeData(my.graph, 
                                                                          x, rxn.id, "color") <- "green")
    }
    if (unname(rates[rxn.id]) > 0) {
      lapply(my.graph@edgeNodeIO$outgoing[[rxn.id]], function(x) edgeData(my.graph, 
                                                                          rxn.id, x, "color") <- "red")
      lapply(my.graph@edgeNodeIO$incoming[[rxn.id]], function(x) edgeData(my.graph, 
                                                                          x, rxn.id, "color") <- "red")
    }
    lwd <- unname(ifelse(lwds[rxn.id] == 2.8, as.character(min(lwds)), 
                         as.character(lwds[rxn.id])))
    lapply(my.graph@edgeNodeIO$outgoing[[rxn.id]], function(x) edgeData(my.graph, 
                                                                        rxn.id, x, "lwd") <- as.character(lwds[rxn.id]))
    lapply(my.graph@edgeNodeIO$incoming[[rxn.id]], function(x) edgeData(my.graph, 
                                                                        x, rxn.id, "lwd") <- as.character(lwds[rxn.id]))
  }
  my.graph@graph@boundBox@botLeft@y <- my.graph@graph@boundBox@botLeft@y - 
    plt.margins[1]
  my.graph@graph@boundBox@botLeft@x <- my.graph@graph@boundBox@botLeft@x - 
    plt.margins[2]
  my.graph@graph@boundBox@upRight@y <- my.graph@graph@boundBox@upRight@y + 
    plt.margins[3]
  my.graph@graph@boundBox@upRight@x <- my.graph@graph@boundBox@upRight@x + 
    plt.margins[4]
   return(my.graph)
}

#Quick function to make minor metabolites.
#CS degree meme goes here
mm_make <- function(o){
  output <- vector("character", length= length(o)*9)
  for(i in 1:length(o)){
    output[9*(i-1)+1] <- paste0(o[i],"[c]")
    output[9*(i-1)+2] <- paste0(o[i],"[e]")
    output[9*(i-1)+3] <- paste0(o[i],"[g]")
    output[9*(i-1)+4] <- paste0(o[i],"[l]")
    output[9*(i-1)+5] <- paste0(o[i],"[m]")
    output[9*(i-1)+6] <- paste0(o[i],"[n]")
    output[9*(i-1)+7] <- paste0(o[i],"[r]")
    output[9*(i-1)+8] <- paste0(o[i],"[x]")
    output[9*(i-1)+9] <- paste0(o[i],"[b]")
  }
  return(output)
}

#standard error.  I'll never understand why base R doesn't have this by default
std <- function(x) sd(x)/sqrt(length(x))

#This function unblocks the specific reactions and performs FVA
FVA_blocked <- function(model, reactions, cores){
  model_ub <- rep(1000, length(reactions))
  model_lb <- rep(0, length(reactions))
  model2 <- changeBounds(model, reactions, lb=model_lb, ub=model_ub)
  
  predicted_fluxes <- multiDel(model2, del1=react_id(model2), nProc=cores, todo="fluxVar")
  predicted_fluxes_df <- lapply(predicted_fluxes, fluxvar_rewrite)
  predicted_fluxes_df <- do.call("rbind", predicted_fluxes_df)
  predicted_fluxes_df
}